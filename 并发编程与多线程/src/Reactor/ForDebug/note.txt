关于TCP的一些笔记：
https://xiaolincoding.com/network/3_tcp/tcp_interview.html#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8-close-%E4%BA%86-%E8%BF%9E%E6%8E%A5%E6%98%AF%E6%96%AD%E5%BC%80%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88

1. 查看端口占用情况 netstat -ano | findstr 8888
2. 服务端调用listen()之后，在操作系统内核会生成两个队列，半连接队列和全连接队列
   服务端调用accept()只是从全连接队列中取出一条tcp连接，这个方法并不会影响TCP三次握手
   客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后
3. 客户端发送的消息，服务端如果来不及取出的话，会放在服务端的缓冲区，下一次缓冲区中的所有数据都是可读的
3. 关于close()方法在TCP四次握手中的体现，这里以客户端主动关闭连接为例。
    客户端调用close()后进入FIN_WAIT_1状态，服务端收到后会自动发送ACK，服务端进入CLOSED_WAIT状态，客户端收到ACK后进入FIN_WAIT_2状态
    然后会在服务端接收缓冲区的最后插入一条结束标注EOF，当使用read()方法读取时，会返回-1，表示这一条连接已经关闭
    服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，应用程序可以通过 read 调用来感知这个 FIN 包。
    服务端当处理完数据后，自然就会读到 EOF，于是我们也调用 close 关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；
    客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；
    服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；.
    客户端经过 2MSL 时间之后，也进入 CLOSE 状态；

SYN 报文被丢弃的两种场景：
- 开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报文被丢弃
- TCP 两个队列满了（半连接队列和全连接队列），造成 SYN 报文被丢弃

已建立连接的TCP，客户端中途宕机，它恢复后向服务端建立连接，服务端收到SYN会发生什么？
- 客户端的 SYN 报文里的端口号与历史连接不相同，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。
- 客户端的 SYN 报文里的端口号与历史连接相同，服务端会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。接着，客户端收到这个 Challenge ACK，
    发现序列号并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。

如何关闭一个 TCP 连接？
- 要伪造一个能关闭 TCP 连接的 RST 报文，必须同时满足「四元组相同」和「序列号正好落在对方的滑动窗口内」这两个条件。
- 我们可以伪造一个四元组相同的 SYN 报文，来拿到“合法”的序列号！

四次挥手中收到乱序的 FIN 包会如何处理？
- 因为如果 FIN 报文比数据包先抵达客户端，此时 FIN 报文其实是一个乱序的报文，此时客户端的 TCP 连接并不会从 FIN_WAIT_2 状态转换到 TIME_WAIT 状态。
在 FIN_WAIT_2 状态下，是如何处理收到的乱序到 FIN 报文，然后 TCP 连接又是什么时候才进入到 TIME_WAIT 状态?
- 在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报文，那么就被会加入到「乱序队列」，并不会进入到 TIME_WAIT 状态。
- 等再次收到前面被网络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列中是否有可用的数据，如果能在乱序队列中找到与当前报文的序列号保持的顺序的报文，就会看该报文是否有 FIN 标志，如果发现有 FIN 标志，这时才会进入 TIME_WAIT 状态。

在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？
- 如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，就会重用此四元组连接，跳过 2MSL 而转变为 SYN_RECV 状态，接着就能进行建立连接过程。
- 如果处于 TIME_WAIT 状态的连接收到「非法的 SYN 」后，就会再回复一个第四次挥手的 ACK 报文，客户端收到后，发现并不是自己期望收到确认号（ack num），就回 RST 报文给服务端。

TCP 连接，一端断电和进程崩溃有什么区别？ 没有开启 keepalive，一直没有数据交互，进程崩溃，主机崩溃
- 客户端主机崩溃了，服务端是无法感知到的，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。
- 如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。
那如果有数据传输呢？
- 只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。
- 超时重直到到达最大次数

拔掉网线后， 原本的 TCP 连接还存在吗？
- 有数据传输，服务端就会触发超时重传机制，重传未得到响应的数据报文。
- 没有数据传输，且没有开启 TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。
    而如果开启了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文。

服务端没有 listen，客户端发起连接建立，会发生什么？
- 服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。

没有 listen，能建立 TCP 连接吗？
- 可以，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），
- 这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。

TCP 四次挥手，可以变成三次吗？
-当被动关闭方在 TCP 挥手过程中，「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。

TCP 延迟确认的策略
- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 AC

关于TCP关闭连接
https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html#%E7%B2%97%E6%9A%B4%E5%85%B3%E9%97%AD-vs-%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD
推荐：客户端调用shutdown()关闭发送方向，服务端在数据发送完成后调用close()关闭连接
shutdown()只有在关闭发送方向时才会发送FIN报文
如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，
所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完整的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭
